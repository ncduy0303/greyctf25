"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_fs_1 = __importDefault(require("node:fs"));
const node_path_1 = __importDefault(require("node:path"));
const memfs_1 = require("memfs");
const vitest_1 = require("vitest");
const getter_1 = require("../getter");
(0, vitest_1.describe)('getter', () => {
    const testDir = '/tmp/test-fs-sfs';
    const getter = (0, getter_1.createGetter)(testDir);
    const sfs = new Proxy(node_fs_1.default, { get: getter });
    (0, vitest_1.beforeEach)(() => {
        // reset the state of in-memory fs
        memfs_1.vol.reset();
        sfs.mkdirSync(testDir, { recursive: true });
    });
    (0, vitest_1.describe)('synchronous API', () => {
        (0, vitest_1.it)('should write and read files correctly', () => {
            const filePath = 'test.txt';
            const content = 'Hello, World!';
            sfs.writeFileSync(filePath, content);
            const readContent = sfs.readFileSync(filePath, 'utf8');
            (0, vitest_1.expect)(readContent).toBe(content);
        });
        (0, vitest_1.it)('should append to files correctly', () => {
            const filePath = 'append-test.txt';
            const initialContent = 'Initial content\n';
            const appendedContent = 'Appended content';
            sfs.writeFileSync(filePath, initialContent);
            sfs.appendFileSync(filePath, appendedContent);
            const finalContent = sfs.readFileSync(filePath, 'utf8');
            (0, vitest_1.expect)(finalContent).toBe(initialContent + appendedContent);
        });
        (0, vitest_1.it)('should create and remove directories correctly', () => {
            const dirPath = 'test-dir';
            sfs.mkdirSync(dirPath);
            (0, vitest_1.expect)(sfs.existsSync(node_path_1.default.join(testDir, dirPath))).toBe(true);
            sfs.rmdirSync(dirPath);
            (0, vitest_1.expect)(sfs.existsSync(node_path_1.default.join(testDir, dirPath))).toBe(false);
        });
        (0, vitest_1.it)('should rename files correctly', () => {
            const oldPath = 'old.txt';
            const newPath = 'new.txt';
            const content = 'Rename test';
            sfs.writeFileSync(oldPath, content);
            sfs.renameSync(oldPath, newPath);
            (0, vitest_1.expect)(sfs.existsSync(node_path_1.default.join(testDir, oldPath))).toBe(false);
            (0, vitest_1.expect)(sfs.existsSync(node_path_1.default.join(testDir, newPath))).toBe(true);
            const readContent = sfs.readFileSync(newPath, 'utf8');
            (0, vitest_1.expect)(readContent).toBe(content);
        });
        (0, vitest_1.it)('should get file stats correctly', () => {
            const filePath = 'stat-test.txt';
            const content = 'Stat test';
            sfs.writeFileSync(filePath, content);
            const stats = sfs.statSync(filePath);
            (0, vitest_1.expect)(stats.isFile()).toBe(true);
            (0, vitest_1.expect)(stats.size).toBe(content.length);
        });
    });
    (0, vitest_1.describe)('asynchronous API', () => {
        (0, vitest_1.it)('should write and read files correctly', async () => {
            const filePath = 'async-test.txt';
            const content = 'Async Hello, World!';
            await new Promise((resolve, reject) => {
                sfs.writeFile(filePath, content, (err) => {
                    if (err)
                        reject(err);
                    else
                        resolve();
                });
            });
            const readContent = await new Promise((resolve, reject) => {
                sfs.readFile(filePath, 'utf8', (err, data) => {
                    if (err)
                        reject(err);
                    else
                        resolve(data);
                });
            });
            (0, vitest_1.expect)(readContent).toBe(content);
        });
        (0, vitest_1.it)('should append to files correctly', async () => {
            const filePath = 'async-append-test.txt';
            const initialContent = 'Initial async content\n';
            const appendedContent = 'Appended async content';
            await new Promise((resolve, reject) => {
                sfs.writeFile(filePath, initialContent, (err) => {
                    if (err)
                        reject(err);
                    else
                        resolve();
                });
            });
            await new Promise((resolve, reject) => {
                sfs.appendFile(filePath, appendedContent, (err) => {
                    if (err)
                        reject(err);
                    else
                        resolve();
                });
            });
            const finalContent = await new Promise((resolve, reject) => {
                sfs.readFile(filePath, 'utf8', (err, data) => {
                    if (err)
                        reject(err);
                    else
                        resolve(data);
                });
            });
            (0, vitest_1.expect)(finalContent).toBe(initialContent + appendedContent);
        });
    });
    (0, vitest_1.describe)('security tests', () => {
        (0, vitest_1.beforeEach)(() => {
            const sensitiveDir = '/etc';
            memfs_1.vol.reset();
            memfs_1.vol.mkdirSync(sensitiveDir, { recursive: true });
        });
        (0, vitest_1.it)('should prevent path traversal attempts', () => {
            const maliciousPath = '../../../etc/passwd';
            const content = 'Malicious content';
            (0, vitest_1.expect)(() => sfs.writeFileSync(maliciousPath, content)).toThrow();
            (0, vitest_1.expect)(() => sfs.readFileSync(maliciousPath)).toThrow();
            (0, vitest_1.expect)(() => sfs.mkdirSync(maliciousPath)).toThrow();
            (0, vitest_1.expect)(() => sfs.rmdirSync(maliciousPath)).toThrow();
            (0, vitest_1.expect)(() => sfs.unlinkSync(maliciousPath)).toThrow();
            (0, vitest_1.expect)(() => sfs.renameSync(maliciousPath, 'new.txt')).toThrow();
            (0, vitest_1.expect)(() => sfs.renameSync('old.txt', maliciousPath)).toThrow();
            (0, vitest_1.expect)(() => sfs.statSync(maliciousPath)).toThrow();
        });
        (0, vitest_1.it)('should prevent absolute path usage', () => {
            const absolutePath = '/etc/passwd';
            const content = 'Absolute path content';
            (0, vitest_1.expect)(() => sfs.writeFileSync(absolutePath, content)).toThrow();
            (0, vitest_1.expect)(() => sfs.readFileSync(absolutePath)).toThrow();
            (0, vitest_1.expect)(() => sfs.mkdirSync(absolutePath)).toThrow();
            (0, vitest_1.expect)(() => sfs.rmdirSync(absolutePath)).toThrow();
            (0, vitest_1.expect)(() => sfs.unlinkSync(absolutePath)).toThrow();
            (0, vitest_1.expect)(() => sfs.renameSync(absolutePath, 'new.txt')).toThrow();
            (0, vitest_1.expect)(() => sfs.renameSync('old.txt', absolutePath)).toThrow();
            (0, vitest_1.expect)(() => sfs.statSync(absolutePath)).toThrow();
        });
        (0, vitest_1.it)('should allow operations within the base path', () => {
            const sfs2 = new Proxy(node_fs_1.default, { get: (0, getter_1.createGetter)('/etc') }); // unsafe usage of the library
            const maliciousPath = 'passwd';
            const content = 'Valid content';
            (0, vitest_1.expect)(() => sfs2.writeFileSync(maliciousPath, content)).not.toThrow();
            (0, vitest_1.expect)(() => sfs2.readFileSync(maliciousPath)).not.toThrow();
            (0, vitest_1.expect)(() => sfs2.renameSync(maliciousPath, 'new.txt')).not.toThrow();
            (0, vitest_1.expect)(() => sfs2.statSync('new.txt')).not.toThrow();
            (0, vitest_1.expect)(() => sfs2.unlinkSync('new.txt')).not.toThrow();
            const validPath = 'valid/nested/path.txt';
            const newPath = 'valid/new.txt';
            (0, vitest_1.expect)(() => sfs.mkdirSync('valid/nested', { recursive: true })).not.toThrow();
            (0, vitest_1.expect)(() => sfs.writeFileSync(validPath, content)).not.toThrow();
            (0, vitest_1.expect)(() => sfs.readFileSync(validPath)).not.toThrow();
            (0, vitest_1.expect)(() => sfs.renameSync(validPath, newPath)).not.toThrow();
            (0, vitest_1.expect)(() => sfs.statSync(newPath)).not.toThrow();
            (0, vitest_1.expect)(() => sfs.unlinkSync(newPath)).not.toThrow();
            (0, vitest_1.expect)(() => sfs.rmdirSync('valid/nested')).not.toThrow();
        });
    });
});
//# sourceMappingURL=fs.test.js.map